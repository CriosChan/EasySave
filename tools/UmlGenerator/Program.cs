using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

internal static class Program
{
    private static readonly Dictionary<string, string> TypeAliases = new()
    {
        ["System.Void"] = "void",
        ["System.String"] = "string",
        ["System.Object"] = "object",
        ["System.Boolean"] = "bool",
        ["System.Byte"] = "byte",
        ["System.SByte"] = "sbyte",
        ["System.Int16"] = "short",
        ["System.UInt16"] = "ushort",
        ["System.Int32"] = "int",
        ["System.UInt32"] = "uint",
        ["System.Int64"] = "long",
        ["System.UInt64"] = "ulong",
        ["System.Single"] = "float",
        ["System.Double"] = "double",
        ["System.Decimal"] = "decimal",
        ["System.Char"] = "char",
        ["System.DateTime"] = "DateTime"
    };

    private static NullabilityInfoContext? _nullabilityContext;

    private static int Main()
    {
        _nullabilityContext = TryCreateNullabilityContext();

        string root = FindSolutionRoot(Directory.GetCurrentDirectory());
        string outDir = Path.Combine(root, "docs", "uml");
        Directory.CreateDirectory(outDir);
        string outFile = Path.Combine(outDir, "EasySave-full.puml");

        var assemblyPaths = new[]
        {
            Path.Combine(root, "EasySave", "bin", "Debug", "net10.0", "EasySave.dll"),
            Path.Combine(root, "EasyLog", "bin", "Debug", "net10.0", "EasyLog.dll")
        };

        var assemblies = assemblyPaths
            .Where(File.Exists)
            .Select(Assembly.LoadFrom)
            .ToList();

        var types = new List<Type>();
        foreach (Assembly asm in assemblies)
        {
            try
            {
                types.AddRange(asm.GetTypes());
            }
            catch (ReflectionTypeLoadException ex)
            {
                types.AddRange(ex.Types.Where(t => t != null)!);
            }
        }

        types = types
            .Where(t =>
                t != null &&
                t.AssemblyQualifiedName != null &&
                !t.IsDefined(typeof(CompilerGeneratedAttribute), false) &&
                t.FullName != null &&
                !t.FullName.StartsWith("<", StringComparison.Ordinal) &&
                t.Name != "AutoGeneratedProgram")
            .ToList();

        var typeSet = types.ToDictionary(t => t.AssemblyQualifiedName!, t => t);

        var aliasMap = new Dictionary<string, string>(StringComparer.Ordinal);
        int aliasIndex = 1;
        foreach (Type t in types.OrderBy(t => t.FullName))
        {
            string key = t.AssemblyQualifiedName ?? t.FullName ?? t.Name;
            if (!aliasMap.ContainsKey(key))
            {
                aliasMap[key] = $"T{aliasIndex:D4}";
                aliasIndex++;
            }
        }

        var sb = new StringBuilder();
        sb.AppendLine("@startuml");
        sb.AppendLine("skinparam classAttributeIconSize 0");
        sb.AppendLine("skinparam linetype ortho");
        sb.AppendLine("skinparam ranksep 80");
        sb.AppendLine("skinparam nodesep 50");
        sb.AppendLine("left to right direction");
        sb.AppendLine("set namespaceSeparator .");
        sb.AppendLine();

        foreach (IGrouping<string, Type> group in types
                     .OrderBy(t => t.Namespace)
                     .ThenBy(t => t.Name)
                     .GroupBy(t => t.Namespace ?? "<global>"))
        {
            sb.AppendLine($"package \"{group.Key}\" {{");
            foreach (Type t in group)
            {
                string umlName = GetDisplayName(t);
                string alias = GetAlias(t, aliasMap);
                if (t.IsEnum)
                {
                    sb.AppendLine($"  enum \"{umlName}\" as {alias} {{");
                    foreach (string name in Enum.GetNames(t))
                        sb.AppendLine($"    {name}");
                    sb.AppendLine("  }");
                    sb.AppendLine();
                    continue;
                }

                string kind = "class";
                if (t.IsInterface) kind = "interface";
                else if (t.IsAbstract && !t.IsSealed) kind = "abstract class";

                string header = kind + " \"" + umlName + "\" as " + alias;
                if (t.IsValueType && !t.IsEnum) header += " <<struct>>";
                sb.AppendLine("  " + header + " {");

                const BindingFlags binding = BindingFlags.Instance | BindingFlags.Static |
                                             BindingFlags.Public | BindingFlags.NonPublic |
                                             BindingFlags.DeclaredOnly;

                foreach (FieldInfo f in t.GetFields(binding))
                {
                    if (f.IsDefined(typeof(CompilerGeneratedAttribute), false)) continue;
                    string vis = GetVisibilitySymbol(f);
                    string mods = "";
                    if (f.IsStatic) mods += "{static} ";
                    if (f.IsInitOnly) mods += "{readonly} ";
                    if (f.IsLiteral) mods += "{const} ";
                    sb.AppendLine($"    {vis} {mods}{f.Name}: {GetSimpleTypeName(f.FieldType)}");
                }

                foreach (PropertyInfo p in t.GetProperties(binding))
                {
                    string vis = GetVisibilitySymbol(p);
                    string mods = "";
                    MethodInfo? accGet = p.GetGetMethod(true);
                    MethodInfo? accSet = p.GetSetMethod(true);
                    if ((accGet != null && accGet.IsStatic) || (accSet != null && accSet.IsStatic))
                        mods += "{static} ";

                    var accessors = new List<string>();
                    if (accGet != null) accessors.Add("get");
                    if (accSet != null) accessors.Add("set");
                    string accText = accessors.Count > 0 ? " { " + string.Join("; ", accessors) + "; }" : "";

                    sb.AppendLine($"    {vis} {mods}{p.Name}: {GetSimpleTypeName(p.PropertyType)}{accText}");
                }

                foreach (EventInfo e in t.GetEvents(binding))
                {
                    MethodInfo acc = e.AddMethod!;
                    string vis = GetVisibilitySymbol(acc);
                    string mods = acc.IsStatic ? "{static} " : "";
                    sb.AppendLine($"    {vis} {mods}event {e.Name}: {GetSimpleTypeName(e.EventHandlerType!)}");
                }

                foreach (ConstructorInfo ctor in t.GetConstructors(binding))
                {
                    string vis = GetVisibilitySymbol(ctor);
                    string mods = ctor.IsStatic ? "{static} " : "";
                    string parameters = string.Join(", ", ctor.GetParameters().Select(FormatParameter));
                    sb.AppendLine($"    {vis} {mods}{GetSimpleTypeName(t)}({parameters})");
                }

                foreach (MethodInfo m in t.GetMethods(binding))
                {
                    if (m.IsSpecialName) continue;
                    string vis = GetVisibilitySymbol(m);
                    string mods = "";
                    if (m.IsStatic) mods += "{static} ";
                    if (m.IsAbstract) mods += "{abstract} ";
                    string parameters = string.Join(", ", m.GetParameters().Select(FormatParameter));
                    sb.AppendLine($"    {vis} {mods}{m.Name}({parameters}): {GetSimpleTypeName(m.ReturnType)}");
                }

                sb.AppendLine("  }");
                sb.AppendLine();
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }

        var relations = new Dictionary<string, Relation>(StringComparer.Ordinal);

        foreach (Type t in types)
        {
            string from = GetAlias(t, aliasMap);

            if (t.BaseType != null && t.BaseType.AssemblyQualifiedName != null &&
                typeSet.ContainsKey(t.BaseType.AssemblyQualifiedName))
            {
                string to = GetAlias(t.BaseType, aliasMap);
                AddRelation(relations, RelationKind.Inheritance, from, to);
            }

            Type[] interfaces = t.GetInterfaces();
            if (t.BaseType != null)
            {
                Type[] baseIfaces = t.BaseType.GetInterfaces();
                interfaces = interfaces.Where(i => !baseIfaces.Contains(i)).ToArray();
            }

            foreach (Type i in interfaces)
            {
                if (i.AssemblyQualifiedName == null) continue;
                if (!typeSet.ContainsKey(i.AssemblyQualifiedName)) continue;
                string to = GetAlias(i, aliasMap);
                AddRelation(relations,
                    t.IsInterface ? RelationKind.Inheritance : RelationKind.Realization,
                    from, to);
            }

            const BindingFlags binding = BindingFlags.Instance | BindingFlags.Static |
                                         BindingFlags.Public | BindingFlags.NonPublic |
                                         BindingFlags.DeclaredOnly;

            foreach (FieldInfo f in t.GetFields(binding))
            {
                if (f.IsDefined(typeof(CompilerGeneratedAttribute), false)) continue;
                foreach ((Type target, string mult) in GetAssociationTargets(f.FieldType, f))
                {
                    Type? resolved = ResolveModelType(target, typeSet);
                    if (resolved == null) continue;
                    string to = GetAlias(resolved, aliasMap);
                    AddRelation(relations, RelationKind.Aggregation, from, to, mult);
                }
            }

            foreach (PropertyInfo p in t.GetProperties(binding))
            {
                foreach ((Type target, string mult) in GetAssociationTargets(p.PropertyType, p))
                {
                    Type? resolved = ResolveModelType(target, typeSet);
                    if (resolved == null) continue;
                    string to = GetAlias(resolved, aliasMap);
                    AddRelation(relations, RelationKind.Aggregation, from, to, mult);
                }
            }
        }

        EnsureOrphansAreLinked(types, aliasMap, typeSet, relations);

        sb.AppendLine();
        foreach (Relation rel in relations.Values.OrderBy(r => r.From).ThenBy(r => r.To).ThenBy(r => r.Kind))
            sb.AppendLine(rel.ToPlantUml());
        sb.AppendLine();
        sb.AppendLine("@enduml");

        File.WriteAllText(outFile, sb.ToString(), Encoding.ASCII);
        Console.WriteLine(outFile);
        return 0;
    }

    private static string FindSolutionRoot(string start)
    {
        string current = start;
        while (!File.Exists(Path.Combine(current, "EasySave.sln")))
        {
            DirectoryInfo? parent = Directory.GetParent(current);
            if (parent == null) break;
            current = parent.FullName;
        }

        return current;
    }

    private static NullabilityInfoContext? TryCreateNullabilityContext()
    {
        try
        {
            return new NullabilityInfoContext();
        }
        catch
        {
            return null;
        }
    }

    private static string GetVisibilitySymbol(MemberInfo member)
    {
        return member switch
        {
            MethodBase m => GetVisibilitySymbol(m),
            FieldInfo f => GetVisibilitySymbol(f),
            PropertyInfo p => GetVisibilitySymbol(p),
            _ => "~"
        };
    }

    private static string GetVisibilitySymbol(MethodBase m)
    {
        if (m.IsPublic) return "+";
        if (m.IsPrivate) return "-";
        if (m.IsFamily) return "#";
        if (m.IsAssembly) return "~";
        if (m.IsFamilyOrAssembly) return "#";
        if (m.IsFamilyAndAssembly) return "#";
        return "~";
    }

    private static string GetVisibilitySymbol(FieldInfo f)
    {
        if (f.IsPublic) return "+";
        if (f.IsPrivate) return "-";
        if (f.IsFamily) return "#";
        if (f.IsAssembly) return "~";
        if (f.IsFamilyOrAssembly) return "#";
        if (f.IsFamilyAndAssembly) return "#";
        return "~";
    }

    private static string GetVisibilitySymbol(PropertyInfo p)
    {
        MethodInfo? acc = p.GetGetMethod(true) ?? p.GetSetMethod(true);
        return acc == null ? "~" : GetVisibilitySymbol(acc);
    }

    private static string GetSimpleTypeName(Type t)
    {
        if (t.IsByRef) t = t.GetElementType()!;
        if (t.IsGenericParameter) return t.Name;
        if (t.IsArray) return GetSimpleTypeName(t.GetElementType()!) + "[]";
        if (t.IsGenericType && t.GetGenericTypeDefinition().FullName == "System.Nullable`1")
            return GetSimpleTypeName(t.GetGenericArguments()[0]) + "?";

        if (TypeAliases.TryGetValue(t.FullName ?? t.Name, out string? alias))
            return alias;

        if (t.IsGenericType)
        {
            string name = t.Name.Split('`')[0];
            string args = string.Join(", ", t.GetGenericArguments().Select(GetSimpleTypeName));
            return $"{name}<{args}>";
        }

        return t.Name;
    }

    private static string GetPlantUmlTypeName(Type t)
    {
        if (t.IsGenericTypeDefinition)
        {
            string baseName = (t.FullName ?? t.Name).Replace("+", ".").Split('`')[0];
            string args = string.Join(", ", t.GetGenericArguments().Select(a => a.Name));
            return $"{baseName}<{args}>";
        }

        string name = (t.FullName ?? t.Name).Replace("+", ".");
        return name.Split('`')[0];
    }

    private static string GetDisplayName(Type t)
    {
        if (t.IsGenericTypeDefinition)
        {
            string baseName = t.Name.Split('`')[0];
            string args = string.Join(", ", t.GetGenericArguments().Select(a => a.Name));
            return $"{baseName}<{args}>";
        }

        return t.Name.Split('`')[0];
    }

    private static string GetAlias(Type t, Dictionary<string, string> aliasMap)
    {
        string key = t.AssemblyQualifiedName ?? t.FullName ?? t.Name;
        if (aliasMap.TryGetValue(key, out string? alias))
            return alias;
        alias = $"T{aliasMap.Count + 1:D4}";
        aliasMap[key] = alias;
        return alias;
    }

    private static bool IsNullableMember(MemberInfo member, Type type)
    {
        if (type.IsValueType)
            return type.IsGenericType && type.GetGenericTypeDefinition().FullName == "System.Nullable`1";

        if (_nullabilityContext != null)
        {
            try
            {
                NullabilityInfo? info = member switch
                {
                    FieldInfo f => _nullabilityContext.Create(f),
                    PropertyInfo p => _nullabilityContext.Create(p),
                    _ => null
                };

                return info != null && info.ReadState == NullabilityState.Nullable;
            }
            catch
            {
                return false;
            }
        }

        return false;
    }

    private static IEnumerable<(Type target, string mult)> GetAssociationTargets(Type type, MemberInfo member)
    {
        foreach (Type t in GetCollectionElementTypes(type))
            yield return (t, "0..*");

        if (IsNullableValueType(type))
        {
            yield return (type.GetGenericArguments()[0], "0..1");
            yield break;
        }

        if (!GetCollectionElementTypes(type).Any())
        {
            string mult = IsNullableMember(member, type) ? "0..1" : "1";
            yield return (type, mult);
        }
    }

    private static IEnumerable<Type> GetDependencyTargets(Type type)
    {
        foreach (Type t in GetCollectionElementTypes(type))
            yield return t;

        if (IsNullableValueType(type))
        {
            yield return type.GetGenericArguments()[0];
            yield break;
        }

        if (!GetCollectionElementTypes(type).Any())
            yield return type;
    }

    private static IEnumerable<Type> GetCollectionElementTypes(Type type)
    {
        if (type.IsByRef) type = type.GetElementType()!;
        if (type.IsArray) return new[] { type.GetElementType()! };
        if (!type.IsGenericType) return Array.Empty<Type>();

        Type def = type.GetGenericTypeDefinition();
        string defName = def.FullName ?? def.Name;

        if (defName is "System.Collections.Generic.Dictionary`2" or
            "System.Collections.Generic.IDictionary`2" or
            "System.Collections.Generic.IReadOnlyDictionary`2")
        {
            return type.GetGenericArguments();
        }

        IEnumerable<Type> ifaces = new[] { type }.Concat(type.GetInterfaces());
        foreach (Type iface in ifaces)
        {
            if (iface.IsGenericType &&
                iface.GetGenericTypeDefinition().FullName == "System.Collections.Generic.IEnumerable`1")
            {
                return new[] { iface.GetGenericArguments()[0] };
            }
        }

        return Array.Empty<Type>();
    }

    private static bool IsNullableValueType(Type type)
        => type.IsGenericType && type.GetGenericTypeDefinition().FullName == "System.Nullable`1";

    private static Type? ResolveModelType(Type type, Dictionary<string, Type> typeSet)
    {
        if (type.IsByRef) type = type.GetElementType()!;
        if (type.AssemblyQualifiedName != null &&
            typeSet.TryGetValue(type.AssemblyQualifiedName, out Type? direct))
            return direct;

        if (type.IsGenericType)
        {
            Type def = type.GetGenericTypeDefinition();
            if (def.AssemblyQualifiedName != null &&
                typeSet.TryGetValue(def.AssemblyQualifiedName, out Type? defType))
                return defType;
        }

        return null;
    }

    private static string FormatParameter(ParameterInfo parameter)
    {
        Type type = parameter.ParameterType;
        string prefix = "";
        if (parameter.IsOut) prefix = "out ";
        else if (type.IsByRef) prefix = "ref ";
        if (type.IsByRef) type = type.GetElementType()!;
        return $"{prefix}{parameter.Name}: {GetSimpleTypeName(type)}";
    }

    private static void EnsureOrphansAreLinked(
        List<Type> types,
        Dictionary<string, string> aliasMap,
        Dictionary<string, Type> typeSet,
        Dictionary<string, Relation> relations)
    {
        var degree = new Dictionary<string, int>(StringComparer.Ordinal);
        foreach (Type t in types)
        {
            string alias = GetAlias(t, aliasMap);
            degree[alias] = 0;
        }

        foreach (Relation rel in relations.Values)
        {
            if (degree.ContainsKey(rel.From)) degree[rel.From]++;
            if (degree.ContainsKey(rel.To)) degree[rel.To]++;
        }

        const BindingFlags binding = BindingFlags.Instance | BindingFlags.Static |
                                     BindingFlags.Public | BindingFlags.NonPublic |
                                     BindingFlags.DeclaredOnly;

        foreach (Type t in types)
        {
            string from = GetAlias(t, aliasMap);
            if (degree[from] > 0) continue;

            foreach (ConstructorInfo ctor in t.GetConstructors(binding))
            {
                foreach (ParameterInfo param in ctor.GetParameters())
                {
                    foreach (Type target in GetDependencyTargets(param.ParameterType))
                    {
                        Type? resolved = ResolveModelType(target, typeSet);
                        if (resolved == null) continue;
                        string to = GetAlias(resolved, aliasMap);
                        AddRelation(relations, RelationKind.Dependency, from, to);
                        degree[from]++;
                        degree[to]++;
                        goto linked;
                    }
                }
            }

            foreach (MethodInfo m in t.GetMethods(binding))
            {
                if (m.IsSpecialName) continue;

                foreach (Type target in GetDependencyTargets(m.ReturnType))
                {
                    Type? resolved = ResolveModelType(target, typeSet);
                    if (resolved == null) continue;
                    string to = GetAlias(resolved, aliasMap);
                    AddRelation(relations, RelationKind.Dependency, from, to);
                    degree[from]++;
                    degree[to]++;
                    goto linked;
                }

                foreach (ParameterInfo param in m.GetParameters())
                {
                    foreach (Type target in GetDependencyTargets(param.ParameterType))
                    {
                        Type? resolved = ResolveModelType(target, typeSet);
                        if (resolved == null) continue;
                        string to = GetAlias(resolved, aliasMap);
                        AddRelation(relations, RelationKind.Dependency, from, to);
                        degree[from]++;
                        degree[to]++;
                        goto linked;
                    }
                }
            }

        linked:
            continue;
        }
    }

    private static void AddRelation(
        Dictionary<string, Relation> relations,
        RelationKind kind,
        string from,
        string to,
        string? multiplicity = null)
    {
        string key = $"{from}|{to}";
        if (relations.TryGetValue(key, out Relation? existing))
        {
            if (existing.Kind <= kind)
            {
                if (existing.Kind == RelationKind.Aggregation && kind == RelationKind.Aggregation)
                {
                    string merged = MergeMultiplicity(existing.MultiplicityTo, multiplicity ?? "1");
                    relations[key] = existing with { MultiplicityTo = merged };
                }
                return;
            }
        }

        relations[key] = new Relation(from, to, kind, "1", multiplicity ?? "1");
    }

    private static string MergeMultiplicity(string current, string incoming)
    {
        if (current == "0..*") return current;
        if (incoming == "0..*") return incoming;
        if (current == "0..1" || incoming == "0..1") return "0..1";
        return "1";
    }
}

internal enum RelationKind
{
    Inheritance = 0,
    Realization = 1,
    Aggregation = 2,
    Dependency = 3
}

internal sealed record Relation(
    string From,
    string To,
    RelationKind Kind,
    string MultiplicityFrom,
    string MultiplicityTo)
{
    public string ToPlantUml()
    {
        return Kind switch
        {
            RelationKind.Inheritance => $"{From} --|> {To}",
            RelationKind.Realization => $"{From} ..|> {To}",
            RelationKind.Aggregation => $"{From} \"{MultiplicityFrom}\" o-- \"{MultiplicityTo}\" {To}",
            RelationKind.Dependency => $"{From} ..> {To}",
            _ => $"{From} ..> {To}"
        };
    }
}
